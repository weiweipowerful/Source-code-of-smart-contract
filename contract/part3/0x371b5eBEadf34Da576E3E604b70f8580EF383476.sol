// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣶⣶⣶⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⠟⠋⠉⠉⠛⣿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⣿⡿⠀⠀⠀⠀⠀⢸⣿⣷⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⠀⠀⠀⠀⠀⣼⣿⣟⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢿⣷⣶⣶⣶⣾⣿⠿⢿⣿⣶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣰⣶⣆⠀⠀⠀⠀⠀⠀⠉⢹⣿⡟⠉⠁⠀⠀⠉⠙⢿⣿⣷⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢀⣀⡀⠀⠀⠀⠀⠀⣀⣴⣾⣿⠿⠛⠁⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⣿⣿⣶⣄⡀⠀⠀⠀⠀⠀⣀⣀⠀⠀⠀⠀⠀
// ⠀⣠⣶⣿⣿⣿⣿⣿⣦⣤⣶⣿⣿⠟⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⢿⣿⣷⣦⣠⣾⣿⣿⣿⣿⣷⣦⡀⠀
// ⢰⣿⡟⠁⠀⠀⠀⠈⣿⣿⡟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⣿⣿⠋⠀⠀⠀⠀⠻⣿⣷⠀
// ⢿⣿⡇⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀⠀⣿⣿⠇
// ⠘⣿⣧⣀⡀⠀⢀⣠⣿⡿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⠿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣦⣀⠀⠀⣀⣼⣿⡟⠀
// ⠀⠈⠻⠿⣿⣿⣿⠿⠟⠁⠀⠀⠀⠀⢀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⠀⠀⠀⠀⠀⠙⠿⢿⣿⣿⡿⠿⠋⠀⠀
// ⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣷⣦⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣾⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⢿⣿⣶⣄⣀⢀⣠⣴⣶⣿⣶⣶⣤⡀⢀⣀⣴⣿⣿⠿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠛⠿⣿⣿⣿⠟⠋⠉⠉⠛⢿⣿⣿⡿⠛⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⠃⠀⠀⠀⠀⠀⠈⢿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣿⡄⠀⠀⠀⠀⠀⢀⣾⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⣿⣿⣦⣄⣀⣀⣤⣾⣿⠛⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠁⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣶⣄⠀⠀⠀⠀⠈⠙⠻⢿⣿⣿⠿⠛⠁⠀⠀⠀⠀⢀⣴⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⢸⣿⠀⠀⠀⠀⠀⠀⢀⣤⣶⣿⡿⠟⠁⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠛⢿⣿⣷⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⢀⣴⣶⣿⣿⣿⣶⣦⣠⣴⣾⣿⠿⠛⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠻⣿⣿⣶⣄⣠⣶⣾⣿⣿⣷⣶⣄⠀⠀
// ⢠⣿⡟⠉⠁⠀⠈⠙⣿⣿⡟⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⣿⣿⠟⠉⠀⠀⠉⢻⣿⣧⠀
// ⣾⣿⡇⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀⠀⣿⣿⡆
// ⠸⣿⣧⡀⠀⠀⠀⢀⣿⣿⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣿⣿⣆⠀⠀⠀⠀⣴⣿⡿⠀
// ⠀⠙⠿⣿⣿⣿⣿⣿⠟⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣤⣾⣿⡿⠟⠛⢿⣿⣿⣿⣿⡿⠟⠁⠀
// ⠀⠀⠀⠀⠈⠉⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣶⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⣿⣿⠿⠋⠁⠀⠀⠀⠀⠀⠉⠉⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⠿⣿⣷⣦⣀⡀⠀⠀⣀⣠⣤⣄⣀⡀⠀⠀⣀⣠⣾⣿⡿⠟⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠿⢿⣿⣶⣾⡿⠿⠿⠿⢿⣿⣶⣾⣿⠿⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿⠀⠀⠀⠀⠀⢻⣿⣯⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣷⠀⠀⠀⠀⠀⢸⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢻⣿⣦⣄⣀⣀⣤⣿⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠛⠿⠿⠿⠛⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀

// SPDX-License-Identifier: MIT
pragma solidity 0.8.27;

/**
 * @title C1Evm - Cross-Chain ETH Transfer Contract
 * @dev Optimized for gas efficiency and cross-chain compatibility
 * @notice Handles ETH transfers with L2 chain integration
 * 
 * Gas Optimization References:
 * - Short names: https://medium.com/coinmonks/gas-optimization-in-solidity-part-i-variables-9d5775e43dde
 * - Custom errors: https://blog.soliditylang.org/2021/04/21/custom-errors/
 * - Assembly usage: https://docs.soliditylang.org/en/v0.8.27/assembly.html
 */
contract C1Evm {
    /**
     * @dev Custom errors save gas compared to require statements
     * Each error saves ~50 gas per revert
     * Reference: https://ethereum.org/en/developers/tutorials/custom-errors-in-solidity/
     */
    error E1(); // PaymentTooLowOrWrongAddress
    error E2(); // Overpayment
    error E3(); // TransferFailed

    /**
     * @dev Main transfer event with optimized parameter names
     * Using single-letter variables in events saves ~8 gas per parameter
     * Indexed parameters allow efficient filtering but cost more gas (~375 gas per indexed param)
     * Reference: https://ethereum.stackexchange.com/questions/8658/what-does-the-indexed-keyword-do
     */
    event T(  // Transfer
        uint256 indexed l,  // l2LinkedId
        uint256 indexed n,  // nonce
        address r,          // recipient
        uint256 a,         // amount
        bytes d            // data
    );

    /**
     * @dev Packed storage struct - fits in one 256-bit slot
     * Storage packing reference: https://docs.soliditylang.org/en/v0.8.27/internals/layout_in_storage.html
     * 
     * Bit layout:
     * [0-95]   : paid amount (uint96)  - Supports up to 79,228,162,514 ETH
     * [96-127] : nonce (uint32)        - Supports up to 4,294,967,295 transfers
     * [128-255]: unused (uint128)      - Reserved for future use
     */
    struct PaymentInfo {
        uint96 p;   // paid - Using uint96 saves gas compared to uint256 for smaller amounts
        uint32 n;   // nonce - uint32 is sufficient for transfer counting
        uint128 u;  // unused - Reserved space for future upgrades
    }
    
    /**
     * @dev Main storage mapping with optimized key generation
     * Using bytes32 for mapping keys is more gas efficient
     * Reference: https://ethereum.stackexchange.com/questions/3373/how-to-clear-large-mappings
     */
    mapping(bytes32 => PaymentInfo) private s; 

    /**
     * @dev Minimum payment constant
     * Using uint8 instead of uint256 saves gas
     * Immutable saves ~2000 gas compared to storage variable
     * Reference: https://docs.soliditylang.org/en/v0.8.27/contracts.html#constant-and-immutable-state-variables
     */
    uint8 private immutable M; 

    constructor() {
        M = 1; // Set minimum payment to 1 wei
    }
    
    /**
     * @dev Key generation function using assembly
     * Assembly provides direct memory access and saves ~30 gas
     * Reference: https://docs.soliditylang.org/en/v0.8.27/assembly.html
     * 
     * Memory layout:
     * [0x00-0x20] : recipient address (32 bytes)
     * [0x20-0x40] : l2LinkedId (32 bytes)
     */
    function k(address r, uint256 l) internal pure returns(bytes32 o) {
        assembly {
            mstore(0x00, r)    // Store address in first memory slot
            mstore(0x20, l)    // Store l2LinkedId in second memory slot
            o := keccak256(0x00, 0x40)  // Hash both slots together
        }
    }

    /**
     * @dev Main transfer function
     * @param l L2 chain identifier for cross-chain tracking
     * @param m Maximum allowed payment (prevents overpayment)
     * @param r Recipient address for ETH transfer
     * @param d Additional data for L2 chain processing
     * 
     * Gas optimizations:
     * - Uses unchecked for safe math operations
     * - Implements assembly for storage operations
     * - Minimizes storage reads/writes
     * Reference: https://ethereum.org/en/developers/tutorials/downsizing-contracts-to-fight-the-contract-size-limit/
     */
    function transfer(
        uint256 l,
        uint256 m,
        address payable r,
        bytes calldata d
    ) external payable {
        // Basic validation with custom errors
        if (r == address(0) || r == address(this) || msg.value < M) revert E1();

        // Load storage once to save gas
        bytes32 x = k(r, l);
        PaymentInfo storage i = s[x];
        
        unchecked {  // Safe math - overflow impossible due to uint96 limit
            uint256 p = uint256(i.p) + msg.value;
            if (p > m) revert E2();
            
            // Get current nonce
            uint256 n = i.n;
            uint256 newNonce = n + 1;
            
            assembly {
                // Efficient storage manipulation using assembly
                let slot := sload(i.slot)
                // Clear all bits first
                slot := 0
                // Put payment in lower 96 bits
                slot := or(slot, p)
                // Put nonce in bits 96-127 (32 bits)
                slot := or(slot, shl(96, newNonce))
                // Store the result
                sstore(i.slot, slot)
            }
            
            assembly {
                if iszero(call(gas(), r, callvalue(), 0, 0, 0, 0)) {
                    mstore(0x00, 0x90b8ec18) // E3 selector
                    revert(0x00, 0x04)
                }
            }

            emit T(l, n, r, msg.value, d);  // Emit the original nonce
        }
    }

    /**
     * @dev View function to check paid amounts
     * @param l L2 chain identifier
     * @param r Recipient address
     * @return Total amount paid for this l2LinkedId/recipient pair
     */
    function paidFor(
        uint256 l,
        address r
    ) external view returns (uint256) {
        return uint256(s[k(r, l)].p);
    }
}