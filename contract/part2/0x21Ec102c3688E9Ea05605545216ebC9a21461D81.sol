/*⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣤⣤⣤⣤⣶⣶⣶⣶⣶⣶⣶⣤⣤⣤⣄⣀⡀⠀⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
                  ⠀⠀⠀⠀⠀⠀⠀⣀⣤⣴⣶⣶⣿⣿⣿⠿⠿⠿⠛⠛⠛⠛⠛⠛⠛⠛⠻⠿⠿⣿⣿⣿⣿⣿⣶⣶⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀
⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠀⢀⣤⣶⣾⣿⠿⠟⠛⠉⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠉⠛⠿⣿⣿⣿⣿⣶⣄⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠀⠀⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣴⣾⠿⠛⠋⠁⠀⠀⠀⠀⠀⠀⠀*** pepecoin.io⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠉⠻⣿⣿⣿⣿⣦⡀⠀⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣴⡿⠟⠉⠀⠀⠀⠀⢀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⣿⣿⣿⣷⡄⠀*** pepecoin.io
⠀⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⡾⠛⠁⠀⠀⢀⣠⣴⣾⣿⣿⣿⣿⣿⣿⣿⣷⣦⣀⠀⠀⠀⣠⣴⣾⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣿⣿⡀
⡀⠄⠀⠀⠄⠀⠀⠀⠀⠀⠈⠀⠀⠀⢀⣴⣿⣿⣿⣿⡿⠿⠛⣛⣉⣭⣭⣉⣉⠛⠷⢶⣿⣿⣿⣿⣿⣿⡿⠿⠛⢋⣩⣭⣵⣶⣯⣭⣟⡳⢤⣀⠀⠀⠀⠀⠀⠸⣿⣿⣿⡇⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀
pepecoin.io⠀⠀⠀⠀⣴⣿⣿⣿⡿⠛⠁⠀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣦⠀⠙⢿⣿⠿⠛⠁⠀⠀⣠⣿⣿⣿⣿⣿⠿⣿⣿⣿⣆⠈⠦⠀⠀⠀⠀⠀⣿⣿⣿⡿⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀
⡀⠄⠀⠀⠄⠀⠀⠀⠀ ⠀⠀⣼⣿⡿⠛⠁⠀⠀⠀⢰⣿⣿⣿⣿⣿⣉⣿⣿⣿⣿⣧⠀⠈⠁⠀⠀⠀⠀⢰⣿⣿⣿⣿⡿⣿⣤⣿⣿⣿⣿⡆⠀⠀⠀⠀⠀⢰⣿⣿⣿⡇
⠀⠀⠀⠀⠀```⠀⠀⠀⢰⣿⣿⣦⣄⠀⠀⠀⠀⣿⣿⣿⣿⣿⣬⣿⣿⠿⣿⣿⣿⠂⠀⠀⠀⠀⠀⠀⢻⣿⣿⣿⣿⣷⣿⣿⡿⢻⣿⣿⡇⠀⢠⠀⠀⢠⣾⣿⣿⣿⠀
⠀⠀⠀⠀⠀⠀⠀⠀⢠⡄⠀⣿⣿⣿⣿⣿⣿⣦⣄⠀⠹⣿⣿⣿⣿⣿⣿⣿⣤⣿⣿⠏⠀⣸⣷⣤⣄⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⣠⣴⡿⢀⣴⣿⣿⣿⡿⠁⠀
⠀⠀⠀⠀⠀⠀⢀⣴⡿⠃⠀⣿⣿⣿⣿⣿⣿⣿⣿⣷⣦⣽⣛⠛⠻⠿⠿⠿⠛⣛⣡⣤⣾⣿⣿⣿⣿⣿⣶⣶⣬⣍⣉⣉⣉⣉⣩⣭⣽⣶⣿⣿⠟⠁⠘⣿⣿⣿⠟⠀⠀⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀
 . .⠀⠀⣴⣿⠋⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠛⠋⠉⠀⠀⠀⠀⣿⠟⠁⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠀⠀⠀⠀
⠀⠀⠀⢀⣾⡿⠁⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠿⠿⠛⠛⠋⠉⠉⠀⠀⠀⣀⣠⡄⠀⠀⠀⣾⣦⡀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠀⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⠀⠀⠀
⠀⠀⢠⣿⡏⠀⠀⠀⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠛⠛⠛⠛⠋⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⠀⢰⣿⣿⣿⣿⠿⠇⠀⠀⠀⣿⣿⣿⣦⠀⠀⠀*** pepecoin.io
⠀⢠⣿⡟⠀⠀⠀⠀⢠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⣶⣶⣶⣦⣤⣀⠠⣤⣴⣶⣶⡆⣿⣿⠿⢿⣿⣷⢸⣿⣇⣀⣠⣤⡆⢠⣶⣾⣿⣿⣿⣿⣷⡄⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠀⠀⠀
⠀⣾⡟⠄⠀⡀⠄⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣽⣿⣿⣿⡇⠀⣿⣿⡏⠙⢿⣿⣶⣿⡏⠉⣉⡀⣿⣿⢀⣰⣿⡿⢸⣿⡿⠿⠿⠿⠃⠈⠻⣿⣿⣿⣿⣿⣿⣿⡄⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠀⠀
⢰⣿⡇⠀⠀⠀⠀⠘⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣇⣤⣾⣿⢿⣿⣿⡿⠿⠇⣿⣿⣿⠿⠟⠁⢸⣿⣇⣀⣠⣤⣴⠀⠀⣸⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀
⣾⣿⠁⠀⠀⠀⠀⠀⠀⠉⠛⣿⣿⣿⣿⣿⣿⣿⣷⣿⣿⣿⡏⠀⣿⣿⡟⠛⠛⠉⢸⣿⣇⣠⣤⣄⣿⣿⠀⠀⠀⠀⢸⠿⠿⠿⠟⣛⣻⡄⣾⣿⣿⠟⠛⠛⠛⠛⠋⠀⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀
⣿⣿⡆⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠿⠿⠇⠀⠀⠀⠸⠿⠿⠟⢛⣃⣛⢻⣄⢠⣤⣶⣶⣶⣄⢸⣿⠛⣛⡃⠙⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⠀
⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⣿⡇⢸⣿⣧⠀⢹⡏⢰⣿⡛⠋⢸⣿⢸⣿⠀⠀⢹⣿⢸⣿⠛⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⢹⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⣿⡇⢸⣿⠻⣷⣼⡇⠀⠙⢿⣦⢸⣿⢸⣿⣤⣤⣾⠟⠸⡿⠾⠟⠃⠀⠀⠀⠀⠀⢀⣤⡆⠀⠀⡀⠄⠀⠀⠄⠀⠀⠀⠀*** pepecoin.io
⠀⣿⣿⣿⣷⡀⠀⠀⠀⠀⠀⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠉⠁⠀⠀⠿⠇⠸⠿⠀⠙⠿⠇⠸⠷⠿⠋⠘⠛⠘⠋⠉⠉⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣶⣾⣿⣿⡇⠀⠀⠀⠀
⠀⠈⢿⣿⣿⣿⣶⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣤⣴⣶⣾⣿⣿⣿⣿⣿⣿⣿⡇⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠀⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀*** pepecoin.io
⠀⠀⠈⠻⣿⣿⣿⣿⣿⣷⣦⣄⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣠⣤⣴⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀
⠀⠀⠀⠀⠈⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣶⣶⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣤⣶⣶⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠟⠋⠁⠀⠀⠀⠀⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄
⠀⠀⠀⠀⠀⠀⠀⠙⠻⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠛⠋⠁⠀⠀⠀⠀⠀⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⠀⠀⠀⠀
pepecoin.io⠀⠈⠙⠻⠿⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠿⠿⠛⠛⠉⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀*** pepecoin.io⠀⠀⠀⠀
⡀⠄⠀⠀⠄⠀⠀⠄⠀⠀⡀⠄⠀⠀⠄⠀⠈⠉⠉⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠉⠉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
*/

// SPDX-License-Identifier: Frensware

pragma solidity ^0.8.20;

import {ERC1155} from "@rari-capital/solmate/src/tokens/ERC1155.sol";
import {ERC20} from "@rari-capital/solmate/src/tokens/ERC20.sol";
import {IERC1155MetadataURI} from "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol";
import {Strings} from "@openzeppelin/contracts/utils/Strings.sol";
import {Counters} from "@openzeppelin/contracts/utils/Counters.sol";
import {Pausable} from "@openzeppelin/contracts/security/Pausable.sol";
import {Ownable} from "solady/src/auth/Ownable.sol";
import {OwnableRoles} from "solady/src/auth/OwnableRoles.sol";
import {ReentrancyGuard} from "solady/src/utils/ReentrancyGuard.sol";
import {ERC2981} from "solady/src/tokens/ERC2981.sol";
import {OperatorFilterer} from "closedsea/src/OperatorFilterer.sol";



contract PepePaint is ERC1155, ERC2981, ReentrancyGuard,
        OperatorFilterer, Pausable, Ownable, OwnableRoles 
    {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    string public constant name = "Pepecoin: Paint Gallery";
    string public constant symbol = "Pepe Paint";

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         STORAGE                            */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    mapping(uint256 => string) private _tokenURIs;
    mapping(uint256 => string) private _showcaseTokenURIs;
    mapping(uint256 => string) private _vipTokenURIs;

    mapping(uint256 => uint256) private _maxSupply;
    mapping(uint256 => uint256) private _currentSupply;

    mapping(address => bool) public whitelist;
    mapping(address => bool) public blacklist;
    mapping(address => bool) public isAuthorized;


    mapping(uint256 => bool) public isShowcaseToken;
    mapping(uint256 => bool) public isAuthToken;


    bool public operatorFilteringEnabled;
    bool public isMintingEnabled = false;

    address public pepecoinAddress;
    address public defaultRoyaltyReceiver;

    uint256 public mintFee;
    uint256 public erc20MintPrice;
    uint96 public royaltyBps;

    uint256 public constant CURATOR_ROLE = _ROLE_0;
    uint256 public constant MAX_PER_TOKEN_ID = 69420;


    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                      CONSTRUCTOR                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/


    constructor(/*//////*/) ERC1155() {
       
        _registerForOperatorFiltering();
        operatorFilteringEnabled = true;
        _initializeOwner(0x6A111f7d28856385263Eedba7E12B37E4EED7997);

        defaultRoyaltyReceiver = 0x3395f8794e8D0Ff3b9b4b43f50f72Ea2d5E61d2c;
        royaltyBps = 500;
        _setDefaultRoyalty(defaultRoyaltyReceiver, royaltyBps);
    }


    modifier onlyOwnerOrCurator() {
        _checkOwnerOrRoles(CURATOR_ROLE);
        _;
    }


    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         MINTS                              */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/


    function mint(string memory tokenURI, uint256 amount)
        public
        payable
        nonReentrant whenNotPaused returns (uint256)
    {
        if (!whitelist[msg.sender]) {
            require(
                msg.value >= mintFee * amount,
                "Insufficient funds to mint"
            );
            require(
                isMintingEnabled, "Minting is not enabled");
            require(
                !blacklist[msg.sender], "blacklisted :'( ");
        }
        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();

        require(
            _currentSupply[newTokenId] + amount <= MAX_PER_TOKEN_ID,
            "Exceeds max per tokenId"
        );

        _mint(msg.sender, newTokenId, amount, "");
        _setTokenURI(newTokenId, tokenURI);
        _currentSupply[newTokenId] += amount;

        return newTokenId;
    }


    function mintWithPepecoin(string memory tokenURI, uint256 amount, uint256 tokenAmount)
    public
    nonReentrant whenNotPaused returns (uint256) 
{
    require(
        isMintingEnabled, "Minting not enabled");
    require(
        !blacklist[msg.sender], "blacklisted :'( ");
    require(
        pepecoinAddress != address(0), "token address not set");
    require(
        erc20MintPrice > 0, "mint price not set");
    uint256 expectedTotalPrice = erc20MintPrice * amount;
    require(
        tokenAmount >= expectedTotalPrice, "Incorrect token amount");
    require(
        ERC20(pepecoinAddress).transferFrom(
            msg.sender,
            address(this),
            tokenAmount
        ),
        "token transfer failed"
    );

        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();

        require(
            _currentSupply[newTokenId] + amount <= MAX_PER_TOKEN_ID,
            "Exceeds max per tokenId"
        );

        _mint(msg.sender, newTokenId, amount, "");
        _setTokenURI(newTokenId, tokenURI);
        _currentSupply[newTokenId] += amount;

        return newTokenId;
    }



    function m1nt(string memory tokenURI, uint256 amount) 
        public
        returns (uint256) 
    {
        require(
            isAuthorized[msg.sender],
             "UNAUTHORIZED KEK"
             );

        _tokenIds.increment();
        uint256 newTokenId = _tokenIds.current();

        require(
            _currentSupply[newTokenId] + amount <= MAX_PER_TOKEN_ID,
             "Exceeds max per tokenId"
             );

        _mint(msg.sender, newTokenId, amount, "");
        _setTokenURI(newTokenId, tokenURI);
        _currentSupply[newTokenId] += amount;

        return newTokenId;
    }

    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                      BURN/REDEEM                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/

    function burn(uint256 id, uint256 amount) public {
        require(
            balanceOf[msg.sender][id] >= amount,
            "Insufficient balance to burn"
        );
        _burn(msg.sender, id, amount);
    }


    function batchBurn(uint256[] memory ids, uint256[] memory amounts) public {
        for (uint256 i = 0; i < ids.length; i++) {
            require(
                balanceOf[msg.sender][ids[i]] >= amounts[i],
                "Insufficient balance to burn"
            );
        }
        _batchBurn(msg.sender, ids, amounts);
    }


    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         CONFIG                             */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/


    function setPepecoinMintFee(uint256 _price) external onlyOwner {
        erc20MintPrice = _price;
    }


    function setFee(uint256 newFee) external onlyOwner {
        mintFee = newFee;
    }


    function batchAddWhitelist(address[] calldata addresses)
        external
        onlyOwnerOrCurator
    {
        for (uint256 i = 0; i < addresses.length; i++) {
            whitelist[addresses[i]] = true;
        }
    }


    function authorize(address[] calldata addresses)
        external
        onlyOwner {
        for (uint256 i = 0; i < addresses.length; i++) {
            isAuthorized[addresses[i]] = true;
        }
    }


    function setPepecoinAddress(address _address) external onlyOwner {
        pepecoinAddress = _address;
    }


    function enableMinting() external onlyOwner {
        isMintingEnabled = true;
    }


    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                         CURATE                             */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/


    function grantCuratorRoles(address[] calldata users) external onlyOwner {
        for (uint256 i = 0; i < users.length; i++) {
            _grantRoles(users[i], CURATOR_ROLE);
        }
    }

    function revokeCuratorRole(address user) external onlyOwner {
        _removeRoles(user, CURATOR_ROLE);
    }


   function uri(uint256 tokenId) public view override returns (string memory) {
        if (bytes(_showcaseTokenURIs[tokenId]).length > 0) {
            return _showcaseTokenURIs[tokenId];
        } else if (bytes(_vipTokenURIs[tokenId]).length > 0) {
                return _vipTokenURIs[tokenId];
            } else {
                return _tokenURIs[tokenId];
        }
    }


    function batchUpdateTokenMetadata(uint256[] calldata tokenIds, string[] calldata newTokenURIs)
        external onlyOwnerOrCurator {   
        require(
            tokenIds.length == newTokenURIs.length,
             "Arrays must be of equal length");
        for (uint256 i = 0; i < tokenIds.length; i++) {
            require(
                _exists(tokenIds[i]),
                 "Token does not exist");
            _tokenURIs[tokenIds[i]] = newTokenURIs[i];
            emit URI(newTokenURIs[i], tokenIds[i]);
        }
    }


    function markAsShowcaseTokens(uint256[] calldata tokenIds) external onlyOwner { 
        for (uint256 i = 0; i < tokenIds.length; i++) {
        require(_exists(tokenIds[i]), "Token does not exist");
            isShowcaseToken[tokenIds[i]] = true;
        }
    }

    
    function markAsAuthTokens(uint256[] calldata tokenIds) external onlyOwner { 
        for (uint256 i = 0; i < tokenIds.length; i++) {
        require(_exists(tokenIds[i]), "Token does not exist");
            isAuthToken[tokenIds[i]] = true;
        }
    }


    function _exists(uint256 tokenId) internal view returns (bool) {
        return bytes(_tokenURIs[tokenId]).length > 0;
    }

    function _setTokenURI(uint256 tokenId, string memory tokenURI) internal {
        require(bytes(_tokenURIs[tokenId]).length == 0, "URI already set");
        _tokenURIs[tokenId] = tokenURI;
    }


    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                     ERC2981 & OPERATOR                     */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/


    function updateDefaultRoyaltyReceiver(address newReceiver, uint96 feeNumerator
    ) public onlyOwner {
        require(
            newReceiver != address(0),
            "Royalty receiver cannot be the zero address"
        );
        require(
            feeNumerator <= _feeDenominator(),
            "Royalty fee exceeds limits"
        );
        defaultRoyaltyReceiver = newReceiver;
        royaltyBps = feeNumerator;
        _setDefaultRoyalty(newReceiver, feeNumerator);
    }


    function setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator
    ) public onlyOwner {
        _setTokenRoyalty(tokenId, receiver, feeNumerator);
    }


    function setApprovalForAll(address operator, bool approved)
        public
        override
        onlyAllowedOperatorApproval(operator)
    {
        super.setApprovalForAll(operator, approved);
    }


    function safeTransferFrom(
        address from,
        address to,
        uint256 tokenId,
        uint256 amount,
        bytes calldata data
    ) public override onlyAllowedOperator(from) {
        super.safeTransferFrom(from, to, tokenId, amount, data);
    }


    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC1155, ERC2981)
        returns (bool)
    {
        return
            ERC1155.supportsInterface(interfaceId) ||
            ERC2981.supportsInterface(interfaceId);
    }


    function setOperatorFilteringEnabled(bool value) public onlyOwner {
        operatorFilteringEnabled = value;
    }


    function _operatorFilteringEnabled() internal view override returns (bool) {
        return operatorFilteringEnabled;
    }


    function _isPriorityOperator(address operator)
        internal
        pure
        override
        returns (bool)
    {
        // OpenSea Seaport Conduit:
        // https://etherscan.io/address/0x1E0049783F008A0085193E00003D00cd54003c71
        // https://goerli.etherscan.io/address/0x1E0049783F008A0085193E00003D00cd54003c71
        return operator == address(0x1E0049783F008A0085193E00003D00cd54003c71);
    }


    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                       MODERATION                           */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/


    function updateTokenMetadata(uint256 tokenId, string memory newTokenURI)
        public
        onlyOwner
    { 
        require(
            _exists(tokenId), "Token does not exist");
        _tokenURIs[tokenId] = newTokenURI;
        emit URI(newTokenURI, tokenId);
    }


    function setBlacklist(address _address) external onlyOwnerOrCurator {
        blacklist[_address] = true;
    }


    function removeFromBlacklist(address _address) external onlyOwnerOrCurator { 
        blacklist[_address] = false;
    }


    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/
    /*                       RESCUE/TREASURY                      */
    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/


    function withdraw() external onlyOwner whenNotPaused {
        uint256 balance = address(this).balance;
        require(
            balance > 0, "mailbox empty x( ");

        (bool success, ) = owner().call{value: balance}("");
        require(
            success, "Withdrawal failed");
    }


    function withdrawERC20(address tokenAddress) external onlyOwner whenNotPaused {
        ERC20 token = ERC20(tokenAddress);
        uint256 balance = token.balanceOf(address(this));

        require(
            balance > 0, "no tokens");
        token.transfer(owner(), balance);
    }
}